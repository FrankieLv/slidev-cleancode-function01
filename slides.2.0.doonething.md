---
layout: center
---

# Rule 2 - Do one thing
1. A function should only do one thing
2. What "one thing" is ?

<!--
1. 仅仅是短小一条规则，对于写出好的函数还是远远不够的。
2. 第二个规则是只做一件事这个原则，已经存在了几十年了，SOLID当中的第一个单一职责原则，也是在强调，一个函数只应该做一件事情。
-->

---

## What "one thing" is ?

<img src="/images/Listing33.png" class="m-1 h-40 rounded shadow" />

<br>

### one thing or three things?

<!--
书中举出的例子是在最后重构好的代码中， 它有三个步骤：
1. 判断是否为测试页面
2. 如果是， 则进行setup and teardown的页面配置。
3. 渲染返回HTML页面。

大家思考一下， 那这个函数是完成一件事情还是完成了三件事情，大家思考一下。
下一页看答案？
-->

---

> 👉 A function does only those steps that are one level below the stated name of function

<br>

> 👉 Team Building - https://frankie-talks-thinking.netlify.app/23

<br>

> 👉 MECE - https://frankie-talks-thinking.netlify.app/27

<!--
答案是这个函数只做了一件事情。
书中给出的概念是一个方法应该只做该函数名下同一抽象层上的步骤，那这个函数就只做了一件事情。
那按照这个概念的定义。

因为不管是判断是否为测试页面，include setup和teardown page 还有返回新页面，这几步都是在函数名下的同一层级的步骤。

对于我个人学习过程而已，这个解释很正确的，但是，在我几年前第一次看这本书的时候，如果给出书中样例代码之外的代码，对于准确地实践这个定义，还是有点含糊不清地，但是现在，我总结了一下个人的思考方式来将这个定义落地，以供大家参考。 

所以，下面的内容是个人理解，仅供参考！！！

这部分是我之前分享过的关于结构化思考的部分，那次并不是全员分享的，有兴趣的可以后续再看看我的slides和笔记。
我认为对于能否将一个方法设计为足够小并且只做一件事情，首先，我们得对所实现的功能能有一个类似于这样的结构思考。

这是举了一个例子关于如何组织我们的teambuilding， 首先我们应该将所有需要完成的事情有一个清晰的结构化思考。讲解一下图中内容。

我们要保证结构图中所有节点都尽可能地满足 MECE原则 - 相互独立，完全穷尽。 上次参加分享的，还有谁记得这个原则是什么？

假设，我们是需要编写代码来实现这个结构图所有的东西，我们可以将每一个节点都理解为一个对应的方法函数。


那如何能实现一个方法只做一件事情，就是：
1. 这个方法不能去做同一层级的其他节点的事情，不要让他们有交集，有交集就以为不是一件事情，就意味在增加阅读负担。
2. 这个方法只包含它下一层也就是子节点的方法的调用，不能去包含孙子节点完成的事情。在书中的代码中， 最开始的方法就包含了所有所有子节点和孙子节点的所有事情，给我们的阅读增加了非常大的负担。
-->

---
layout: center
---

```mermaid {scale: 2}
flowchart TB
    subgraph "testableHtml()"

    id1(((I'm all)))

    end
```
<!--
那么以这种思维方式，再回过头来看书中代码最开始的版本，从结构图中来看，就是所有层级的代码都混合再一起。

它没有不同层级level的划分，所以，它所带来的阅读负担，只要读过这些代码的就都可以体会的到。
-->
---
layout: center
---

<img src="/images/fitnesscodethinking.png" class="rounded shadow" />

<!--

那我们对书中的样例代码实现的功能，进行一个结构化的思考，如这个图所示，我们就可以很清晰的知道每个方法所处的层级。

讲解每个方法都是在做一件事情，因为每个方法都只是包含它的子层级的方法。

基于这种方式，我们可以很轻松的知道当前方法所属层级，所表达所讲述的故事。我们可以自由的决定是否再需要深入去查看它下一层的详细内容。我们会有一个很少的阅读负担，很好的约定体验。

在这些方法中，高层级的代码，比如。。。 我们都可以把他们理解为胶水代码，他们只是在同一层级的抽象，将整个流程串联起来，实际上它并没有真正的去完成需要做的事情，只有最底层的代码才是细节，才是要完成的事情。

还有一种快速检验你的方法是否足够小，是否只做一件事，就是像Nate叔说的，可以按照TDD的方式去思考，如果自己写junit test code来测试你这个方法，是否足够轻松和简单，如果你自己都在挣扎于测试方法的期望结果到底是什么，那就得考虑是否方法不够好。

-->

